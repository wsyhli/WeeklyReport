#Using Compose is basically a three-step process:
#  Define your app’s environment with a Dockerfile so it can be reproduced anywhere.
#  Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment.
#  Run docker compose up and the Docker compose command starts and runs your entire app. You can alternatively run docker-compose up using the docker-compose binary.
version: "3.3"
services:
#  nginx:
#    image: nginx:latest # 镜像版本
#    ports:
#      - "80:80" # 端口暴露
#    volumes: # 将主机的数据卷或着文件挂载到容器里
#      - /app/nginx/webafter:/usr/share/nginx/webafter
#      - /app/nginx/nginx.conf:/etc/nginx/nginx.conf
#    privileged: true # 解决nginx文件调用权限

  mysql:
    image: mysql:5.7
    ports:
      - "3306:3306"
    environment: # 指定密码
      - MYSQL_ROOT_PASSWORD=123456
    restart: always
    container_name: mysql666
    volumes:
      - ./conf/my.conf:/etc/my.conf
      - ./data:/var/lib/mysql

#
#  redis:
#    image: aea9b698d7d1 # redis:latest的IMAGE ID
#
  week:
    image: week:test
    build: . # 表示以当前目录下的Dockerfile开始构建镜像，由于单独执行过docker build -t week:v1 . 因此不用在这里使用build指令
    # When mapping ports in the HOST:CONTAINER format, you may experience erroneous results when using a container port lower than 60,
    # because YAML parses numbers in the format xx:yy as a base-60 value. For this reason,
    # we recommend always explicitly specifying your port mappings as strings.
    ports:
      - "8082:8082"





